(ns sicp-practice.ex-2-6)

;; 自然数の定義(公理?)っぽいのは何か他にあったよなと思ったらペアノの公理でした
;; http://ja.wikipedia.org/wiki/自然数
;; 集合を使ってうまくやってる
;; 余談でした...

;; SICPに書いてある最初の定義はこんなの
(def zero (fn [f] (fn [x] x)))

(defn add-1 [n]
  ;; nは普通の数字かと思いきや、関数です。nを適用させたりしているから
  (fn [f] (fn [x] (f ((n f) x)))))

;; 問題は
;; (zeroとadd-1を使わずに)「oneとtwoを定義せよ」
;; と
;; (add-1の繰り返し作用させず)加算手続き+を直接定義せよ
;; いうもの

;; ヒント
;; (add-1 zero)を評価するのに、置き換えを使おう。

;; ヒントに愚直に従う
;; (add-1 zero)
;; add-1定義を展開 =>
;; ((fn [f] (fn [x] (f ((n f) x)))) zero)
;; zeroを代入 =>
;; (fn [f] (fn [x] (f ((zero f) x)))))
;; zeroの定義を代入 =>
;; (fn [f]
;;   (fn [x] (f (((fn [f']
;; 		 (fn [x'] x'))
;; 	       f)
;; 	      x))))
;; f'は結局無視される =>
;; (fn [f]
;;   (fn [x] (f x)))

;; zeroをadd-1するというのは結局xに対してfを1回適用する、ということらしい
;; なにがどうしてこんな回りくどいことになった...

;; 上の説明に基づくと、0に対してincを1回適用すると1が出てくるはず
(((add-1 zero) inc) 0) ; 1
;; よしよし

;; 最初の問題(zeroとadd-1を使わずに)「oneとtwoを定義せよ」について考えてみる
;; 上の例を見ると結局zeroは関数だった
;; oneもtwoも関数で定義させたいに違いない(きっと)
;; zeroは関数fを0回作用させていたからoneは1回作用させる感じで

(def one (fn [f]
	   (fn [x] (f x))))

((one inc) 0) ; 1

;; twoはまぁ2回作用させればいいんでしょう

(def two (fn [f]
	   (fn [x] (f (f x)))))

((two inc) 0) ; 2

;; (ある意味)こっからが本番
;; 次の問題は(add-1の繰り返し作用させず)「加算手続き+を直接定義せよ」というもの
;; oneもtwoも結局関数で、きっと関数合成っぽい考え方でも使うんだろう
;; 自然数が閉じているように、関数合成した結果も(引数に取った関数の方と同じ関数で)閉じていると使い回せて便利だよ、ということをやりたいんだと思います。きっとたぶん...
(defn my-add [num1 num2] ;; Note: num1とnum2はそれぞれ関数
  (fn [f]
    (fn [x]
      ((num2 f) ((num1 f) x)))))

;; 意味不明だったadd-1の定義がこの辺で生きてくる <= (n f)の付近
;; (num2 f)というのは型(?)としてはスカラーxを引数に取るような関数(どんな関数かはnum2による)
;; (num1 f)の型も同様
;; ((num1 f) x)は上のような関数にxを適用させる => ただのスカラー(数字)
;; ((num2 f) ((num1 f) x))はスカラーを取る関数にスカラーを適用させている

;; 型はこんな感じで、次に意味について考えてみる
;; num1やnum2についてはoneやtwoのような関数が入力として入ってくる
;; (num1 f)はfを(ここでは一般的な数字としての意味の)num1回適用するような関数が返ってくる
;; ((num1 f) x)はそんな関数にxを適用させる => (f (f ... (f x)))がnum1回続く
;; (num2 f)はfをnum2回適用するような関数が返ってくる
;; ((num2 f) ((num1 f) x))は(f (f ... (f x)))がnum1+num2回続くようなものとなる!

;; 確かめてみる
(((my-add one two) inc) 0) ; 3
(((my-add (my-add one two) two) inc) 0) ; 5
;; ｷﾀ━━━━━━(ﾟ∀ﾟ)━━━━━━ !!!!!

;; 結局、何がうれしかったんじゃい、ってことですが
;; my-addの入力として入ってくるnum1やnum2が
;; (fn [f] (fn [x] ...))
;; という形としていて、my-addの出力も
;; (fn [f] (fn [x] ...))
;; という形をしていると、それをまた入力として使い回せる、閉じた性質を持っている、ってことがうれしいよね、と言いたかったんだと思います。きっとたぶん